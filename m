Return-Path: <linux-serial-owner@vger.kernel.org>
X-Original-To: lists+linux-serial@lfdr.de
Delivered-To: lists+linux-serial@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 8F1AF363480
	for <lists+linux-serial@lfdr.de>; Sun, 18 Apr 2021 11:47:15 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229891AbhDRJrl (ORCPT <rfc822;lists+linux-serial@lfdr.de>);
        Sun, 18 Apr 2021 05:47:41 -0400
Received: from smtp-35.italiaonline.it ([213.209.10.35]:54758 "EHLO libero.it"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S229756AbhDRJrl (ORCPT <rfc822;linux-serial@vger.kernel.org>);
        Sun, 18 Apr 2021 05:47:41 -0400
Received: from passgat-Modern-14-A10M.homenet.telecomitalia.it
 ([95.244.94.151])
        by smtp-35.iol.local with ESMTPA
        id Y41ClAcrIpK9wY41HlZ94m; Sun, 18 Apr 2021 11:47:12 +0200
x-libjamoibt: 1601
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=libero.it; s=s2021;
        t=1618739232; bh=FdbYlXhVuQEKZrfvlD50hIEZK6SUIqLOeYeJss0nRPA=;
        h=From;
        b=W/KBl1UdKQOXa7Vf9kz/MNck841XJqPW05FBTKPipOItitfLIF1q6W8BC5oI5Nx62
         1N3aTG29oRDME/r5Op8olxE8jqKG1zj08IqLHogwoCeis7rwWc47IOYPm6zVSW3RRK
         UwD0sqP2ghqFHRhx9UKaj+1is56Z3QIIT86IB5VNo0itEYsjq1zY0y4b8OpPGQ3NHr
         5vxKwNdSNd99D9vqBLucECUkzTxrp8Ow6EnfOWjU+iiAxs9LcsortqhLcQIctjvqd4
         +aIhq3MH17vB6szioeg1Qz/NqQH9XVVX57UAReLTXoTRz4Zh/U1QOo9lOP59cy8lM+
         EH4hW4RXuL32w==
X-CNFS-Analysis: v=2.4 cv=A9ipg4aG c=1 sm=1 tr=0 ts=607c0020 cx=a_exe
 a=ugxisoNCKEotYwafST++Mw==:117 a=ugxisoNCKEotYwafST++Mw==:17
 a=RNOFN41U3FZ75c9ZyJUA:9
From:   Dario Binacchi <dariobin@libero.it>
To:     linux-kernel@vger.kernel.org
Cc:     Dario Binacchi <dariobin@libero.it>,
        Dimitris Lampridis <dlampridis@logikonlabs.com>,
        Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        Jiri Slaby <jirislaby@kernel.org>, linux-serial@vger.kernel.org
Subject: [PATCH v4] serial: omap: fix rs485 half-duplex filtering
Date:   Sun, 18 Apr 2021 11:47:05 +0200
Message-Id: <20210418094705.27014-1-dariobin@libero.it>
X-Mailer: git-send-email 2.17.1
X-CMAE-Envelope: MS4xfJJUDC1EHnfgAYrCbcZSgBaVQevW0CJJkRWSfJVHAGCC5m/3BZV/WvHlyYgzHClLiA27tmHj+gdnvichinwUcxHq5bwTpMh4OsfnF39cE5QZkWoXVlbO
 I8sAbi8wA5f5xBDPtuVrIWgK06ObZNmz4qYoNiiyvZsTOzLB4oNngJTrBN71JF/AmGMIKg+ef//15SMN8OgK+WHv6Ird+8lKGym0SlzrMgaFmJtLCj6KWqyF
 Yl+EUh5zPvkaRRwnIU8kqOfYSqi5JAMlHSuG/hnmJoSEjZOQQp3sxK3DMnAtPL14DAkkNPV5DeDuECqSNnMNo9ggxGLgg9knbVMeDonVlXdRmysqWWb2dqnO
 xzUPDf7ujo9AmWN/l0jJ0PmKa4xRyZX6QsNhXLJr7bLDBSVzIfmYoS7Sq1KcfPlAazYZBOYc
Precedence: bulk
List-ID: <linux-serial.vger.kernel.org>
X-Mailing-List: linux-serial@vger.kernel.org

Data received during half-duplex transmission must be filtered.
If the target device responds quickly, emptying the FIFO at the end of
the transmission can erase not only the echo characters but also part of
the response message.
By keeping the receive interrupt enabled even during transmission, it
allows you to filter each echo character and only in a number equal to
those transmitted.
The issue was generated by a target device that started responding
240us later having received a request in communication at 115200bps.
Sometimes, some messages received by the target were missing some of the
first bytes.

Fixes: 3a13884abea0 ("tty/serial: omap: empty the RX FIFO at the end of half-duplex TX")
Signed-off-by: Dario Binacchi <dariobin@libero.it>


---

Changes in v4:
- Change the type of the rs485_tx_filter_count variable from atomic_t
  to unsigned int and related read / write accesses.

Changes in v3:
- Add 'Fixes' tag

Changes in v2:
- Fix compiling error

 drivers/tty/serial/omap-serial.c | 39 ++++++++++++++++++++------------
 1 file changed, 24 insertions(+), 15 deletions(-)

diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index 76b94d0ff586..f8fafceb5803 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -159,6 +159,8 @@ struct uart_omap_port {
 	u32			calc_latency;
 	struct work_struct	qos_work;
 	bool			is_suspending;
+
+	unsigned int		rs485_tx_filter_count;
 };
 
 #define to_uart_omap_port(p) ((container_of((p), struct uart_omap_port, port)))
@@ -328,19 +330,6 @@ static void serial_omap_stop_tx(struct uart_port *port)
 		serial_out(up, UART_IER, up->ier);
 	}
 
-	if ((port->rs485.flags & SER_RS485_ENABLED) &&
-	    !(port->rs485.flags & SER_RS485_RX_DURING_TX)) {
-		/*
-		 * Empty the RX FIFO, we are not interested in anything
-		 * received during the half-duplex transmission.
-		 */
-		serial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_RCVR);
-		/* Re-enable RX interrupts */
-		up->ier |= UART_IER_RLSI | UART_IER_RDI;
-		up->port.read_status_mask |= UART_LSR_DR;
-		serial_out(up, UART_IER, up->ier);
-	}
-
 	pm_runtime_mark_last_busy(up->dev);
 	pm_runtime_put_autosuspend(up->dev);
 }
@@ -366,6 +355,10 @@ static void transmit_chars(struct uart_omap_port *up, unsigned int lsr)
 		serial_out(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
 		up->port.x_char = 0;
+		if ((up->port.rs485.flags & SER_RS485_ENABLED) &&
+		    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX))
+			up->rs485_tx_filter_count++;
+
 		return;
 	}
 	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
@@ -377,6 +370,10 @@ static void transmit_chars(struct uart_omap_port *up, unsigned int lsr)
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		up->port.icount.tx++;
+		if ((up->port.rs485.flags & SER_RS485_ENABLED) &&
+		    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX))
+			up->rs485_tx_filter_count++;
+
 		if (uart_circ_empty(xmit))
 			break;
 	} while (--count > 0);
@@ -420,7 +417,7 @@ static void serial_omap_start_tx(struct uart_port *port)
 
 	if ((port->rs485.flags & SER_RS485_ENABLED) &&
 	    !(port->rs485.flags & SER_RS485_RX_DURING_TX))
-		serial_omap_stop_rx(port);
+		up->rs485_tx_filter_count = 0;
 
 	serial_omap_enable_ier_thri(up);
 	pm_runtime_mark_last_busy(up->dev);
@@ -491,8 +488,13 @@ static void serial_omap_rlsi(struct uart_omap_port *up, unsigned int lsr)
 	 * Read one data character out to avoid stalling the receiver according
 	 * to the table 23-246 of the omap4 TRM.
 	 */
-	if (likely(lsr & UART_LSR_DR))
+	if (likely(lsr & UART_LSR_DR)) {
 		serial_in(up, UART_RX);
+		if ((up->port.rs485.flags & SER_RS485_ENABLED) &&
+		    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX) &&
+		    up->rs485_tx_filter_count)
+			up->rs485_tx_filter_count--;
+	}
 
 	up->port.icount.rx++;
 	flag = TTY_NORMAL;
@@ -543,6 +545,13 @@ static void serial_omap_rdi(struct uart_omap_port *up, unsigned int lsr)
 		return;
 
 	ch = serial_in(up, UART_RX);
+	if ((up->port.rs485.flags & SER_RS485_ENABLED) &&
+	    !(up->port.rs485.flags & SER_RS485_RX_DURING_TX) &&
+	    up->rs485_tx_filter_count) {
+		up->rs485_tx_filter_count--;
+		return;
+	}
+
 	flag = TTY_NORMAL;
 	up->port.icount.rx++;
 
-- 
2.17.1

